**# CS320**

The following repository contains all projects I've done in my CS 320 class at SNHU. Java applications are tested automated through JUnit in this course. It was entirely my responsibility to develop the code and test cases to be tested thoroughly from the ground up.


**How can I ensure that my code, program, or software is functional and secure?**

The importance of manual review is just as great as the importance of automated testing. For this project, testing with plug-ins like JUnit was an essential factor in producing clean, readable, and functional, enabling viewing of coverage to ensure everything was properly tested. Nevertheless, manually reviewing your code is equally vital. Creating an application or program requires the use of both components. I ensure that my code, program, or software is functional and secure through continuous manual and automated testing. Coding a whole program does not happen simultaneously; I periodically stop to test and check my code. Doing so prevents me from completing the entire code and getting lost when errors occur. In addition, my ability to see what went wrong or what needed to be done becomes more apparent when I work on smaller chunks of code.

**How do I interpret user needs and incorporate them into a program?**

The user's needs drive the initial development of the application, so ignoring them can not happen. Developers must never forget that the user sometimes wants more than is realistic, but developers are limited to delivering a few of those requirements; the task is to meet their requirements in the middle. You may not be able to create something exactly that your client wants due to time, budget, and tools, but creativity pays off when it results in other solutions. An important skill for any developer is to look past what you can't do, find solutions, and present to try instead.

**How do I approach designing software?**

In developing software, I typically begin by considering what I wish the overall application to accomplish, then I build incrementally, adding on as I go. To make something work, I do not always consider how many objects I will need or how many methods will need to be created. I begin to write code when I know what I want to do. At various times I pause development during development to review my code for possible refactorings or changes as I hit roadblocks, and as my code grows longer, I do the same. Where I can, incorporating methods or solutions developed before or modifying them to fit my needs saves time as well. By removing menial coding tasks, I can focus more on essential things like flow and scope and less on minor issues like syntax errors.
